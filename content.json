{"meta":{"title":"blog","subtitle":null,"description":null,"author":"Jeffrey Fu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"js原型、原型链、继承相关学习心得","slug":"js原型、原型链、继承相关学习心得","date":"2019-06-20T03:24:22.000Z","updated":"2019-06-21T07:34:58.000Z","comments":true,"path":"2019/06/20/js原型、原型链、继承相关学习心得/","link":"","permalink":"http://yoursite.com/2019/06/20/js原型、原型链、继承相关学习心得/","excerpt":"","text":"前置知识点： js基本数据类型和引用数据类型（基本数据类型有： null, undefined, Boolen, Number, String, Symbol） 计算机堆、栈内存（栈内存存的是基本类型和引用类型的地址，堆内存由于树状结构可以延伸适合引用类型如Array, Object） js中this指向及bind，call，apply方法使用，参阅call、apply和bind的实现 引生思考点 js语言原型和原型链为什么这么设计，好处与不好之处，与Java语言最大的区别是什么？ 浅拷贝与深拷贝如何实现？ js闭包知识点 js原型、原型链基本概念ES5 和 ES6 继承的区别 ES5原型链继承 12345678910111213141516171819function Super() &#123; this.xxx = 'hello world!';&#125;Super.prototype.sayHello = function() &#123; console.log(this.xxx);&#125;function Son() &#123; // ...&#125;Son.prototype = new Super(); // 原型链式继承// Son.prototype = Object.create(Super.prototype);Son.prototype.constructor = Son; // 修复constructorvar sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!'; 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例instanceof方法通过层层查找原型链判断的 缺点： 来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参 ES6继承 12345678910111213141516class Super &#123; constructor() &#123; this.xxx = 'hello world!'; &#125; sayHello() &#123; console.log(this.xxx); &#125;&#125;class Son extends Super &#123; // ...&#125;var sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!'; ES6继承和原型链式继承还是有本质区别的，ES6中 Son 类实例是自己本身拥有了xxx属性的（ES5的调用父类构造函数继承） ES6中方法都是不可枚举的，Son 类实例调用 sayHello 方法和原型式继承原理类似 ES5中构造函数是function函数本身，而ES6中构造函数是 constructor 函数 关于ES6 class 可以重开一篇博客了, 先推荐阅读两篇文章 ES6 javascript中class静态方法、属性与实例属性用法示例 react组件中的constructor和super小知识 以上图片引用自keenwon.com ES5实现继承的其它方式调用父类构造函数继承123456789101112131415function Super(xxx) &#123; this.xxx = xxx;&#125;Super.prototype.sayHello = function() &#123; console.log(this.xxx);&#125;function Son() &#123; Super.call(this, 'hello world!'); // 调用父类构造函数&#125;var sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!';sonInstance.sayHello(); // TypeError: sonInstance.sayHello is not a function 特点： 创建子类实例时，可以向父类传递参数 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 组合继承12345678910111213141516171819function Super(xxx) &#123; this.xxx = xxx;&#125;Super.prototype.sayHello = function() &#123; console.log(this.xxx);&#125;function Son() &#123; Super.call(this, 'hello world!'); // 调用父类构造函数&#125;Son.prototype = new Super();Son.prototype.constructor = Son; // 修复constructorvar sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!';sonInstance.sayHello(); // 'hello world!'; 特点： 创建子类实例时，可以向父类传递参数 既是子类的实例，也是父类的实例 实例拥有与父类同名的自己的属性（亦是缺点） 既能继承父类的实例属性和方法，又能继承原型属性/方法 缺点： 调用了两次父类构造函数，子类实例上属性将子类原型上的那份屏蔽了 寄生组合继承12345678910111213141516171819function Super(xxx) &#123; this.xxx = xxx;&#125;function Son(xxx) &#123; Super.call(this, xxx); // 调用父类构造函数&#125;// 创建一个空方法，避免再次调用父类的构造函数(function () &#123; var Temp = function() &#123;&#125;; Temp.prototype = Super.prototype; Son.prototype = new Temp();&#125;)();Son.prototype.constructor = Son; // 修复constructorvar sonInstance = new Son('hello world!');console.log(sonInstance.xxx); // 'hello world!'; 特点： 结合以上所有继承方式的优点 完整的原型图 参考文章： 完整原型链详细图解（构造函数、原型、实例化对象） JS实现继承的几种方式 详解ES5和ES6的继承","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"原型","slug":"原型","permalink":"http://yoursite.com/tags/原型/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"前端面试必考题Promise的源码解析","slug":"前端面试必考题Promise的源码解析","date":"2019-06-18T09:55:45.000Z","updated":"2019-06-19T08:20:32.000Z","comments":true,"path":"2019/06/18/前端面试必考题Promise的源码解析/","link":"","permalink":"http://yoursite.com/2019/06/18/前端面试必考题Promise的源码解析/","excerpt":"","text":"考察知识点： js迭代器 js构造函数、原型、原型链 js执行栈、事件循环机制 伪源码实现：Promise构造函数 创建一个Promise实例，通过new一个Promise（接受一个函数作为参数），该函数接受resolve, reject两个方法作为参数。 每个Promise只有三种状态：pending，fulfilled 和 rejected，状态只能从 pending 转移到 fulfilled 或者 rejected，一旦状态变成fulfilled 或者 rejected，就不能再更改其状态。 123456789101112131415161718192021222324252627282930function Promise3(executor) &#123; const self = this; self.status = 'pending'; self.value = undefined; self.reason = undefined; self.onResolvedCallbacks = []; self.onRejectedCallbacks = []; function resolve(value) &#123; if (self.status === 'pending') &#123; self.status = 'resolved'; self.value = value; self.onResolvedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; function reject(reason) &#123; if (self.status === 'pending') &#123; self.status = 'rejected'; self.reason = reason; self.onRejectedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125; 定义在Promise原型上方法then，可被实例调用 通过判断上一个Promise的状态执行不同的代码 正常情况下第一个Promise执行器中是异步代码，会先执行then()函数，then函数两个参数onFulfilled，onRejected会被暂存到onResolvedCallbacks，onRejectedCallbacks中，在第一步的异步执行器executor(resolve, reject)中完成执行 为了实现Promise的链式调用，在then方法中return promise，所以在new Promise的执行器中手动加了setTimeout实现异步执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Promise3.prototype.then = function (onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === 'function' ? onRejected : err =&gt; &#123; throw err &#125;; const self = this; let promise2; if (self.status === 'resolved') &#123; promise2 = new Promise3(function(resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status === 'rejected') &#123; promise2 = new Promise3(function(resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status === 'pending') &#123; promise2 = new Promise3(function(resolve, reject) &#123; self.onResolvedCallbacks.push(function () &#123; setTimeout(function() &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; onRejected(e); &#125; &#125;); &#125;); self.onRejectedCallbacks.push(function () &#123; setTimeout(function() &#123; try &#123; let x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; onRejected(e); &#125; &#125;); &#125;); &#125;); &#125; return promise2;&#125; 定义resolvePromise方法 上一个Promise返回值有3中情况（也是该函数取名的缘由） 普通值 promise对象 thenable对象/函数 通过自身迭代和在then方法中的引用，直至返回resolve普通值或者报错 12345678910111213141516171819202122232425262728293031function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError('Chaining cycle')); // 循环引用报错 &#125; let called; if (x &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123; let then = x.then; if (typeof then === 'function') &#123; then.call(x, function(y) &#123; if (called) return; called = true; resolvePromise(promise2, y, resolve, reject); &#125;, function(err) &#123; if (called) return; called = true; reject(err); &#125;); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125; Promise的静态方法及其它方法：Promise.resolve1234567891011121314Promise.resolve = function (param) &#123; if (param instanceof Promise) &#123; return param; &#125; return new Promise((resolve, reject) =&gt; &#123; if (param &amp;&amp; param.then &amp;&amp; typeof param.then === 'function') &#123; setTimeout(() =&gt; &#123; param.then(resolve, reject); &#125;); &#125; else &#123; resolve(param); &#125; &#125;);&#125; Promise.reject12345Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125; Promise.prototype.catch123Promise.prototype.catch = function (onRejected) &#123; return this.then(null, onRejected);&#125; Promise.prototype.finally1234567891011Promise.prototype.catch = function (callback) &#123; return this.then((value) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; return value; &#125;); &#125;, (err) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; throw err; &#125;); &#125;);&#125; Promise.all123456789101112131415161718192021222324Promise.all = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let index = 0; let result = []; if (promises.length === 0) &#123; resolve(result); &#125; else &#123; function processValue(i, data) &#123; result[i] = data; if (++index === promises.length) &#123; resolve(result); &#125; &#125; promises.forEach((promise, i) =&gt; &#123; Promise.resolve(promise).then((data) =&gt; &#123; processValue(i, data); &#125;, (err) =&gt; &#123; reject(err); return; &#125;); &#125;); &#125; &#125;);&#125; Promise.race1234567891011121314151617Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; if (promises.length === 0) &#123; return; &#125; else &#123; promises.forEach((promise, i) =&gt; &#123; Promise.resolve(promise).then((data) =&gt; &#123; resolve(data); return; &#125;, (err) =&gt; &#123; reject(err); return; &#125;); &#125;); &#125; &#125;);&#125; promise测试库12npm install promises-aplus-tests -Dnpx promises-aplus-tests promise.js 参考文章： Promise/A+ 规范文档 Promise详解与实现（Promise/A+规范） 手写实现满足 Promise/A+ 规范的 Promise Promise的源码实现（完美符合Promise/A+规范） 手动实现一个满足promises-aplus-tests的Promise","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"读李飞飞人物志有感","slug":"读李飞飞人物志有感","date":"2019-06-04T08:32:44.000Z","updated":"2019-06-21T07:44:36.000Z","comments":true,"path":"2019/06/04/读李飞飞人物志有感/","link":"","permalink":"http://yoursite.com/2019/06/04/读李飞飞人物志有感/","excerpt":"","text":"20世纪70年代，李飞飞生于成都。 那时的成都，远没有今天繁华。但是，李飞飞的父母特别注重培养她的好奇心，一有展览就带她去，让她接触到更大的世界、更新奇的事物。 同时，家里还有一条很有趣的家规：李飞飞放学回家后只能在40分钟内做作业，40分钟后就可以看课外书、可以玩，干啥都可以，但就是不能再做作业。 父母此举，就是为了让李飞飞养成专注高效的习惯，做事不拖延，不左顾右盼。这样，就可以为自己留出充足时间，做自己感兴趣的事。 程序人生她拒绝麦肯锡 Offer，建立图片训练数据库，斯坦福 AI 实验室负责人 | 人物志 为这种教育方式点赞，相比近期被推到热点新闻的996上班制度，工作效率才是应该提高的方向。","categories":[{"name":"life","slug":"life","permalink":"http://yoursite.com/categories/life/"}],"tags":[{"name":"education","slug":"education","permalink":"http://yoursite.com/tags/education/"}],"keywords":[{"name":"life","slug":"life","permalink":"http://yoursite.com/categories/life/"}]},{"title":"Hexo+Github","slug":"Hexo-Github","date":"2019-05-28T08:43:49.000Z","updated":"2019-05-29T03:37:25.000Z","comments":true,"path":"2019/05/28/Hexo-Github/","link":"","permalink":"http://yoursite.com/2019/05/28/Hexo-Github/","excerpt":"","text":"Hexo+GitHub 搭建个人网站教程 Hexo简介 Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。首先电脑上需要安装Node.js依赖。 12345$ npm install hexo-cli -g ##安装hexo脚手架$ hexo init blog ##初始化hexo$ cd blog$ npm install$ hexo server","categories":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}],"keywords":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-25T18:17:52.000Z","updated":"2019-05-29T03:54:21.000Z","comments":true,"path":"2018/08/26/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}]}]}