{"meta":{"title":"jeffrey's blog","subtitle":null,"description":null,"author":"Jeffrey Fu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"js执行上下文、词法作用域、块级作用域相关学习","slug":"js执行上下文、词法作用域、块级作用域相关学习","date":"2019-06-26T10:07:21.000Z","updated":"2019-06-28T05:48:38.000Z","comments":true,"path":"2019/06/26/js执行上下文、词法作用域、块级作用域相关学习/","link":"","permalink":"http://yoursite.com/2019/06/26/js执行上下文、词法作用域、块级作用域相关学习/","excerpt":"","text":"JavaScript引擎JavaScript引擎的一个流行示例是Google的V8引擎。例如，在Chrome和Node.js中使用V8引擎，下面是一个非常简化的视图： 浏览器中的JavaScript解释器是作为一个单线程实现的，这实际上意味着，在浏览器中，一次只能发生一件事，其他操作或事件将排队在所谓的执行堆栈中。 lvwxxJavaScript中的执行上下文和堆栈是什么 词法作用域 函数作用域和块级作用域 块级作用域与函数声明 ES5 只有全局作用域和函数作用域，没有块级作用域。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 阮一峰块级作用域 感受下let和var的区别 12345678var aa = 'bb';function fn()&#123; console.log(aa); &#123; // 在块级作用域内var声明变量 var aa = 'aa'; &#125;&#125;fn(); // undefined 12345678var aa = 'bb';function fn()&#123; console.log(aa); &#123; // 在块级作用域内let声明变量 let aa = 'aa'; &#125;&#125;fn(); // 'bb' 123456789101112function bs()&#123; console.log(1);&#125;function fn()&#123; bs(); &#123; // 在块级作用域内声明函数 function bs()&#123; console.log(2); &#125; &#125;&#125;fn(); // TypeError: bs is not a function 变量提升暂时性死区使用let/const声明的变量，从一开始就形成了封闭作用域，在声明变量之前是无法使用这个变量的，这个特点也是为了弥补var的缺陷（var声明的变量有变量提升） yeyan1996近一万字的ES6语法知识点补充 12console.log(aa); // ReferenceError: Cannot access 'aa' before initialization）let aa; 剖析暂时性死区的原理，其实let/const同样也有提升的作用，但是和var的区别在于： var在创建时就被初始化，并且赋值为undefined let/const在进入块级作用域后，会因为提升的原因先创建，但不会被初始化，直到声明语句执行的时候才被初始化，初始化的时候如果使用let声明的变量没有赋值，则会默认赋值为undefined，而const必须在初始化的时候赋值。而创建到初始化之间的代码片段就形成了暂时性死区 yeyan1996近一万字的ES6语法知识点补充 ES6 Class 不存在变量提升1234console.log(Test); // ReferenceError: Cannot access 'Test' before initializationclass Test &#123; // ...&#125; 解释器如何评估JS代码（evaluate） 扫描被调用函数中的代码 在代码执行前，创建执行上文 进入创建阶段 初始化作用域链 创建变量对象 创建arguments对象，检查参数上下文，初始化名称和值，并创建引用副本 扫描上下文中函数的声明 对于找到的每个函数，在变量对象中创建一个属性，该属性是确切的函数名，该函数在内存中有一个指向该函数的引用指针 如果函数名已经存在，指针将会被覆盖 扫描变量的声明 对于找到的每个变量，在变量对象中创建一个属性，该属性是确切的变量名，该变量的值是undefined 如果变量名已经存在，将不会做任何处理继续执行 决定this的值 代码执行阶段 变量赋值，按顺序执行代码 lvwxxJavaScript中的执行上下文和堆栈是什么 结合自身的感悟如下： 知道了js代码执行前有预编译这么一回事，也就能掌握变量提升，解释器根据var, function等关键字进行预编译，function是一等公民 123456789101112131415(function() &#123;console.log(foo); // foo() &#123; return 'hello'; &#125;console.log(bar); // undefinedvar bar = function() &#123; return 'world';&#125;;function foo() &#123; return 'hello';&#125;var foo = 'hello';&#125;());​ 词法作用域决定了函数执行上下文作用域，跟函数在哪调用没有关系（this在任何情况下都不指向函数的词法作用域，this是在函数运行时，创建上下文的时候确定的） 12345678910111213141516171819function a() &#123; var myOtherVar = \"inside A\"; b();&#125;function b() &#123; var myVar = \"inside B\"; console.log(\"myOtherVar:\", myOtherVar); // 'global otherVar' function c() &#123; console.log(\"myVar:\", myVar); // 'inside B' &#125; c();&#125;var myOtherVar = \"global otherVar\";var myVar = \"global myVar\";a(); 执行上下文执行上下文：当前代码正在执行的环境（作用域），一般有以下三种情况： 全局代码 – 代码首次开始执行的默认环境 函数代码 – 每当进入一个函数内部 Eval代码 – eval内部代码执行时 lvwxxJavaScript中的执行上下文和堆栈是什么 Nothing special is going on here, we have 1 global context represented by the purple border and 3 different function contexts represented by the green, blue and orange borders. There can only ever be 1 global context, which can be accessed from any other context in your program. You can have any number of function contexts, and each function call creates a new context, which creates a private scope where anything declared inside of the function can not be directly accessed from outside the current function scope. In the example above, a function can access a variable declared outside of its current context, but an outside context can not access the variables / functions declared inside.（理解为作用域链） David Shariffwhat-is-the-execution-context-in-javascript 现在我们知道每当有函数被调用时，都会创建一个新的执行上下文。在js内部，每个执行上文创建都要经历下面2个阶段： 创建阶段（函数被调用，但还没有执行内部代码） 创建作用域链 创建变量和参数 决定this指向 代码执行阶段 变量赋值，执行代码 lvwxxJavaScript中的执行上下文和堆栈是什么 this 全面解析 推荐阅读：刘小夕 - 嗨，你真的懂this吗？ 闭包 参考文章： JavaScript中的执行上下文和堆栈是什么 JavaScript是如何工作的：引擎，运行时和调用堆栈的概述！ JavaScript 究竟是怎样执行的？ 精读《你不知道的 javascript（上卷）》 精读《你不知道的 javascript（中卷）》 What is the Execution Context & Stack in JavaScript? 你不可不知道的 JavaScript 作用域和闭包 JS函数作用域以及变量提升问题 块级作用域（阮一峰·ECMAScript 6 入门）","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"编译","slug":"编译","permalink":"http://yoursite.com/tags/编译/"},{"name":"作用域","slug":"作用域","permalink":"http://yoursite.com/tags/作用域/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"js原型、原型链、继承相关学习心得","slug":"js原型、原型链、继承相关学习心得","date":"2019-06-20T03:24:22.000Z","updated":"2019-06-26T11:45:36.000Z","comments":true,"path":"2019/06/20/js原型、原型链、继承相关学习心得/","link":"","permalink":"http://yoursite.com/2019/06/20/js原型、原型链、继承相关学习心得/","excerpt":"","text":"前置知识点： js基本数据类型和引用数据类型（基本数据类型有： null, undefined, Boolen, Number, String, Symbol） 计算机堆、栈内存（栈内存存的是基本类型和引用类型的地址，堆内存由于树状结构可以延伸适合引用类型如Array, Object） js中this指向及bind，call，apply方法使用，参阅call、apply和bind的实现 引生思考点 js语言原型和原型链为什么这么设计，好处与不好之处，与Java语言最大的区别是什么？ 浅拷贝与深拷贝如何实现？ js闭包知识点 js原型、原型链基本概念ES5 和 ES6 继承的区别 ES5原型链继承 12345678910111213141516171819function Super() &#123; this.xxx = 'hello world!';&#125;Super.prototype.sayHello = function() &#123; console.log(this.xxx);&#125;function Son() &#123; // ...&#125;Son.prototype = new Super(); // 原型链式继承// Son.prototype = Object.create(Super.prototype);Son.prototype.constructor = Son; // 修复constructorvar sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!'; 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例instanceof方法通过层层查找原型链判断的 缺点： 来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参 ES6继承 12345678910111213141516class Super &#123; constructor() &#123; this.xxx = 'hello world!'; &#125; sayHello() &#123; console.log(this.xxx); &#125;&#125;class Son extends Super &#123; // ...&#125;var sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!'; ES6继承和原型链式继承还是有本质区别的，ES6中 Son 类实例是自己本身拥有了xxx属性的，因为在子类的constructor构造函数中运行super()方法调用了父类构造函数（ES5的调用父类构造函数继承） ES6中方法都是不可枚举的，Son 类实例调用 sayHello 方法和原型式继承原理类似 ES5中构造函数是function函数本身，而ES6中构造函数是 constructor 函数 关于ES6 class 可以重开一篇博客了, 先推荐阅读两篇文章 ES6 javascript中class静态方法、属性与实例属性用法示例 react组件中的constructor和super小知识 以上图片引用自keenwon.com 实现ES6的class语法（2019-06-26·补充）123456789101112function inherit(subType, superType) &#123; subType.prototype = Object.create(superType.prototype, &#123; constructor: &#123; enumerable: false, configurable: true, writable: true, value: subType, &#125; &#125;); Object.setPrototypeOf(subType, superType);&#125; ES6 的 class 内部是基于寄生组合式继承，它是目前最理想的继承方式，通过 Object.create 方法创造一个空对象，并将这个空对象继承 Object.create 方法的参数，再让子类（subType）的原型对象等于这个空对象，就可以实现子类实例的原型等于这个空对象，而这个空对象的原型又等于父类原型对象（superType.prototype）的继承关系 而 Object.create 支持第二个参数，即给生成的空对象定义属性和属性描述符/访问器描述符，我们可以给这个空对象定义一个 constructor 属性更加符合默认的继承行为，同时它是不可枚举的内部属性（enumerable:false） 而 ES6 的 class 允许子类继承父类的静态方法和静态属性，而普通的寄生组合式继承只能做到实例与实例之间的继承，对于类与类之间的继承需要额外定义方法，这里使用 Object.setPrototypeOf 将 superType 设置为 subType 的原型，从而能够从父类中继承静态方法和静态属性 yeyan1996一个合格的中级前端工程师必须要掌握的28个JavaScript技巧 ES5实现继承的其它方式调用父类构造函数继承123456789101112131415function Super(xxx) &#123; this.xxx = xxx;&#125;Super.prototype.sayHello = function() &#123; console.log(this.xxx);&#125;function Son() &#123; Super.call(this, 'hello world!'); // 调用父类构造函数&#125;var sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!';sonInstance.sayHello(); // TypeError: sonInstance.sayHello is not a function 特点： 创建子类实例时，可以向父类传递参数 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 组合继承12345678910111213141516171819function Super(xxx) &#123; this.xxx = xxx;&#125;Super.prototype.sayHello = function() &#123; console.log(this.xxx);&#125;function Son() &#123; Super.call(this, 'hello world!'); // 调用父类构造函数&#125;Son.prototype = new Super();Son.prototype.constructor = Son; // 修复constructorvar sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!';sonInstance.sayHello(); // 'hello world!'; 特点： 创建子类实例时，可以向父类传递参数 既是子类的实例，也是父类的实例 实例拥有与父类同名的自己的属性（亦是缺点） 既能继承父类的实例属性和方法，又能继承原型属性/方法 缺点： 调用了两次父类构造函数，子类实例上属性将子类原型上的那份屏蔽了 寄生组合继承12345678910111213141516171819function Super(xxx) &#123; this.xxx = xxx;&#125;function Son(xxx) &#123; Super.call(this, xxx); // 调用父类构造函数&#125;// 创建一个空方法，避免再次调用父类的构造函数(function () &#123; var Temp = function() &#123;&#125;; Temp.prototype = Super.prototype; Son.prototype = new Temp();&#125;)();Son.prototype.constructor = Son; // 修复constructorvar sonInstance = new Son('hello world!');console.log(sonInstance.xxx); // 'hello world!'; 特点： 结合以上所有继承方式的优点 完整的原型图 参考文章： 完整原型链详细图解（构造函数、原型、实例化对象） JS实现继承的几种方式 详解ES5和ES6的继承","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"原型","slug":"原型","permalink":"http://yoursite.com/tags/原型/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"前端面试必考题Promise的源码解析","slug":"前端面试必考题Promise的源码解析","date":"2019-06-18T09:55:45.000Z","updated":"2019-06-19T08:20:32.000Z","comments":true,"path":"2019/06/18/前端面试必考题Promise的源码解析/","link":"","permalink":"http://yoursite.com/2019/06/18/前端面试必考题Promise的源码解析/","excerpt":"","text":"考察知识点： js迭代器 js构造函数、原型、原型链 js执行栈、事件循环机制 伪源码实现：Promise构造函数 创建一个Promise实例，通过new一个Promise（接受一个函数作为参数），该函数接受resolve, reject两个方法作为参数。 每个Promise只有三种状态：pending，fulfilled 和 rejected，状态只能从 pending 转移到 fulfilled 或者 rejected，一旦状态变成fulfilled 或者 rejected，就不能再更改其状态。 123456789101112131415161718192021222324252627282930function Promise3(executor) &#123; const self = this; self.status = 'pending'; self.value = undefined; self.reason = undefined; self.onResolvedCallbacks = []; self.onRejectedCallbacks = []; function resolve(value) &#123; if (self.status === 'pending') &#123; self.status = 'resolved'; self.value = value; self.onResolvedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; function reject(reason) &#123; if (self.status === 'pending') &#123; self.status = 'rejected'; self.reason = reason; self.onRejectedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125; 定义在Promise原型上方法then，可被实例调用 通过判断上一个Promise的状态执行不同的代码 正常情况下第一个Promise执行器中是异步代码，会先执行then()函数，then函数两个参数onFulfilled，onRejected会被暂存到onResolvedCallbacks，onRejectedCallbacks中，在第一步的异步执行器executor(resolve, reject)中完成执行 为了实现Promise的链式调用，在then方法中return promise，所以在new Promise的执行器中手动加了setTimeout实现异步执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Promise3.prototype.then = function (onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === 'function' ? onRejected : err =&gt; &#123; throw err &#125;; const self = this; let promise2; if (self.status === 'resolved') &#123; promise2 = new Promise3(function(resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status === 'rejected') &#123; promise2 = new Promise3(function(resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status === 'pending') &#123; promise2 = new Promise3(function(resolve, reject) &#123; self.onResolvedCallbacks.push(function () &#123; setTimeout(function() &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; onRejected(e); &#125; &#125;); &#125;); self.onRejectedCallbacks.push(function () &#123; setTimeout(function() &#123; try &#123; let x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; onRejected(e); &#125; &#125;); &#125;); &#125;); &#125; return promise2;&#125; 定义resolvePromise方法 上一个Promise返回值有3中情况（也是该函数取名的缘由） 普通值 promise对象 thenable对象/函数 通过自身迭代和在then方法中的引用，直至返回resolve普通值或者报错 12345678910111213141516171819202122232425262728293031function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError('Chaining cycle')); // 循环引用报错 &#125; let called; if (x &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123; let then = x.then; if (typeof then === 'function') &#123; then.call(x, function(y) &#123; if (called) return; called = true; resolvePromise(promise2, y, resolve, reject); &#125;, function(err) &#123; if (called) return; called = true; reject(err); &#125;); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125; Promise的静态方法及其它方法：Promise.resolve1234567891011121314Promise.resolve = function (param) &#123; if (param instanceof Promise) &#123; return param; &#125; return new Promise((resolve, reject) =&gt; &#123; if (param &amp;&amp; param.then &amp;&amp; typeof param.then === 'function') &#123; setTimeout(() =&gt; &#123; param.then(resolve, reject); &#125;); &#125; else &#123; resolve(param); &#125; &#125;);&#125; Promise.reject12345Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125; Promise.prototype.catch123Promise.prototype.catch = function (onRejected) &#123; return this.then(null, onRejected);&#125; Promise.prototype.finally1234567891011Promise.prototype.catch = function (callback) &#123; return this.then((value) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; return value; &#125;); &#125;, (err) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; throw err; &#125;); &#125;);&#125; Promise.all123456789101112131415161718192021222324Promise.all = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let index = 0; let result = []; if (promises.length === 0) &#123; resolve(result); &#125; else &#123; function processValue(i, data) &#123; result[i] = data; if (++index === promises.length) &#123; resolve(result); &#125; &#125; promises.forEach((promise, i) =&gt; &#123; Promise.resolve(promise).then((data) =&gt; &#123; processValue(i, data); &#125;, (err) =&gt; &#123; reject(err); return; &#125;); &#125;); &#125; &#125;);&#125; Promise.race1234567891011121314151617Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; if (promises.length === 0) &#123; return; &#125; else &#123; promises.forEach((promise, i) =&gt; &#123; Promise.resolve(promise).then((data) =&gt; &#123; resolve(data); return; &#125;, (err) =&gt; &#123; reject(err); return; &#125;); &#125;); &#125; &#125;);&#125; promise测试库12npm install promises-aplus-tests -Dnpx promises-aplus-tests promise.js 参考文章： Promise/A+ 规范文档 Promise详解与实现（Promise/A+规范） 手写实现满足 Promise/A+ 规范的 Promise Promise的源码实现（完美符合Promise/A+规范） 手动实现一个满足promises-aplus-tests的Promise","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"读李飞飞人物志有感","slug":"读李飞飞人物志有感","date":"2019-06-04T08:32:44.000Z","updated":"2019-06-21T07:44:36.000Z","comments":true,"path":"2019/06/04/读李飞飞人物志有感/","link":"","permalink":"http://yoursite.com/2019/06/04/读李飞飞人物志有感/","excerpt":"","text":"20世纪70年代，李飞飞生于成都。 那时的成都，远没有今天繁华。但是，李飞飞的父母特别注重培养她的好奇心，一有展览就带她去，让她接触到更大的世界、更新奇的事物。 同时，家里还有一条很有趣的家规：李飞飞放学回家后只能在40分钟内做作业，40分钟后就可以看课外书、可以玩，干啥都可以，但就是不能再做作业。 父母此举，就是为了让李飞飞养成专注高效的习惯，做事不拖延，不左顾右盼。这样，就可以为自己留出充足时间，做自己感兴趣的事。 程序人生她拒绝麦肯锡 Offer，建立图片训练数据库，斯坦福 AI 实验室负责人 | 人物志 为这种教育方式点赞，相比近期被推到热点新闻的996上班制度，工作效率才是应该提高的方向。","categories":[{"name":"life","slug":"life","permalink":"http://yoursite.com/categories/life/"}],"tags":[{"name":"education","slug":"education","permalink":"http://yoursite.com/tags/education/"}],"keywords":[{"name":"life","slug":"life","permalink":"http://yoursite.com/categories/life/"}]},{"title":"Hexo+Github","slug":"Hexo-Github","date":"2019-05-28T08:43:49.000Z","updated":"2019-05-29T03:37:25.000Z","comments":true,"path":"2019/05/28/Hexo-Github/","link":"","permalink":"http://yoursite.com/2019/05/28/Hexo-Github/","excerpt":"","text":"Hexo+GitHub 搭建个人网站教程 Hexo简介 Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。首先电脑上需要安装Node.js依赖。 12345$ npm install hexo-cli -g ##安装hexo脚手架$ hexo init blog ##初始化hexo$ cd blog$ npm install$ hexo server","categories":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}],"keywords":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-25T18:17:52.000Z","updated":"2019-05-29T03:54:21.000Z","comments":true,"path":"2018/08/26/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}]}]}