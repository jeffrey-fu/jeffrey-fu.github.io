{"meta":{"title":"jeffrey's blog","subtitle":null,"description":null,"author":"Jeffrey Fu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Java零基础学习笔记","slug":"Java零基础学习笔记","date":"2021-03-04T12:24:29.000Z","updated":"2021-03-07T17:03:56.813Z","comments":true,"path":"2021/03/04/Java零基础学习笔记/","link":"","permalink":"http://yoursite.com/2021/03/04/Java零基础学习笔记/","excerpt":"","text":"图片来自网络 边学边记重点：阿里云大学Java学习路线在线调试工具：online_java_debugger Java编程入门 一个.class文件对应一个类 int型数据范围 (-2147483648 ~ 2147483647) 1int num = Integer.MAX_VALUE + 2L // -2147483647 char类型用&#39;&#39;，String类型用&quot;&quot; Java面向对象编程 如何正确声明一个类并进行实例化后调用 12345678910111213141516171819202122232425262728293031class Person &#123; // 声明一个Person类 private String name; // 属性封装 private static String country; // 类静态属性，可通过类或其实例对象调用(有别于js) public Person() &#123; // 类构造方法，没有返回值，没有void以区别普通函数 // this()必须在构造函数内调用，且优先于其它代码执行 this(\"invoke construct fun with param\"); &#125; public Person(String name) &#123; // 类构造方法重载 this.name = name; // this指向实例化对象 &#125; // 类静态方法，无法使用this，无法调用非静态属性及方法 // 因为静态的属性和方法可直接通过类调用，无需实例化对象 public static void setCountry(String c) &#123; country = c; &#125; public String getName() &#123; // getter return this.name; &#125; public void setName(String name) &#123; // setter 修改属性值 this.name = name; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Person p1 = new Person(\"jeff\"); p1.setName(\"jeffrey\"); Person.setCountry(\"中国\"); System.out.println(\"name: \" + p1.getName()); &#125;&#125;","categories":[{"name":"back-end","slug":"back-end","permalink":"http://yoursite.com/categories/back-end/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"back-end","slug":"back-end","permalink":"http://yoursite.com/categories/back-end/"}]},{"title":"2019年8月前端面试总结","slug":"2019年8月前端面试总结","date":"2019-09-15T08:43:54.000Z","updated":"2019-09-15T14:36:48.000Z","comments":true,"path":"2019/09/15/2019年8月前端面试总结/","link":"","permalink":"http://yoursite.com/2019/09/15/2019年8月前端面试总结/","excerpt":"","text":"关于裸辞在2019年下半年，整个互联网圈不怎么景气的大环境下，我选择了裸辞，并且对自己的选择没有后悔。原因如下： 很多企业在政府政策导向下撤离市中心往余杭、萧山等周边区域搬迁，前公司也不例外，在每天往返3小时的煎熬下毅然决定在新项目启动之前递交辞职。 之前是以实习生的身份转正几乎没有面试经验，想着可要好好地准备面试。 关于本人即将奔三、非科班、接触前端一年半时间 面试经历 以下问题全凭面试结束后的回忆： 有赞微商城 有赞技术团队 CSS相关 IE盒子模型和标准盒子模型区别 伪类、伪元素（::first-line, ::first-letter, ::after, ::before） CSS选择器优先级：!importent &gt; 内联样式 &gt; id选择器 &gt; class选择器 … CSS实现垂直、水平居中方法 flex-box常用属性值 position属性值：static(默认值), relative, absolute, fixed, sticky JS相关 Object.prototype.toString.call 为什么能输出[object Object]? 原型，原型链，继承方式 call、apply、bind 浏览器Event-Loop React相关 React生命周期函数 组件名为什么要大写：跟JSX语法解析用以区分原生html元素 class组件和function组件区别 虚拟Dom如何渲染 React Diff算法 render机制，父子组件渲染引发re-render问题 React Hooks React Router两种模式hash、history区别(hash模式#后面的内容不会发送到服务器，history模式下nginx服务器需要设置try_files) 算法相关 求两个数组的交集 涂鸦智能面试 React16 新的生命周期函数static getDerivedStateFromProps、getSnapShotBeforeUpdate等 ​ 初始化阶段：constructor =&gt; componentWillReceiveProps（static getDerivedStateFromProps） =&gt; componentWillMount =&gt; render =&gt; componentDidMount =&gt; componentWillUnmount ​ 更新阶段：componentWillReceiveProps（static getDerivedStateFromProps） =&gt; shouldComponentUpdate =&gt; componentWillUpdate =&gt; render =&gt; componentDidUpdate React16 fiber纤程原理 有哪些字段 性能优化体现在哪里（React性能瓶颈在哪？diff算法耗时？） React Components Class和Function组件声明方式的区别？更新机制不同？ React Hooks相比原Class写法有哪些优势 React JSX -&gt; babel转译 -&gt; React库createElement生成dom树 -&gt; React-DOM库render方法调用DOM原生api挂载浏览器dom树上 React虚拟Dom的原理，diff算法（三种方式），key作用 redux源码阅读，设计思想，订阅监听设计模式 redux中间件的理解，包装dispatch，异步回掉方式改变state？ TypeScript有哪些基本类型：泛型、元组 Tuple、枚举 Webpack打包原理、插件和loader发生在打包的哪个阶段 凌笛数码面试 React中 this绑定方式（bind(this)，箭头函数），两种方式的区别 Redux原理 React路由懒加载原理 pureComponent原理（如何避免不必要的re-render） Webpack tree-shaking的原理 手写深拷贝函数 ES7、ES8有哪些新方法（装饰器属于ES6） Promise、Generator、async await方法区别（Generator的暂停） 闭包（如何释放闭包） Array的所有方法（注意是否改变原数组sort，fill，lastIndexOf，map，includes，join，reverse，reduce，copyWithin） ES6 … 扩展语法的原理（遍历器接口，被for … of循环遍历） 寻找字符串中连续出现次数最多的字符 12345678910111213141516171819202122var str = \"bvaafffaaazzzaa\";function calc(str) &#123; var arr = str.split(''); var temp =[]; var obj = &#123;&#125;; var count = -1; arr.forEach((s, index) =&gt; &#123; if (s === arr[index - 1] || s === arr[index + 1]) &#123; if (s !== arr[index - 1]) &#123; ++ count; &#125; temp[count] ? temp[count].push(s) : temp[count] = [s]; &#125; &#125;); var max = Math.max.apply(null, temp.map((arr) =&gt; arr.length)); var maxArr = temp.filter((arr) =&gt; arr.length === max); maxArr.forEach((arr) =&gt; &#123; obj[arr[0]] = max; &#125;); return obj;&#125;console.log(calc(str)); 正则表达式解法参考： JS正则表达式完整教程·反向引用 正则表达式匹配重复的字符串[超详细]附完整实例 睿轶信息 Chrome突破：font-size：12px zoom:1 浏览器标签页之间进行通信onMessage/postMessage， Margin重叠BFC，Z-index：层叠顺序问题， LocalStorage如何突破5M，SessionStorage Cookie区别， PWA，H5离线开发了解，存储在哪 AMD\\CMD\\CommonJS 区别 this.setState方法同步异步问题（合成事件原理） 变量提升 12345678910111213141516171819var a = 10;function fun() &#123; console.log(a); var b = a = 20; console.log(a);&#125;fun();var a = 10;function fun() &#123; console.log(a); var a = b = 20; console.log(a);&#125;fun(); 面试准备 React高频面试题梳理，看看面试怎么答？（上） List of (Advanced) JavaScript Questions（上） 20道JS原理题助你面试一臂之力！ 这儿有20道大厂面试题等你查收 【Step-By-Step】高频面试题深入解析 / 周刊01 react新生命周期替代旧生命周期的最佳实践 面试总结 建议在Boss直聘上找，相比之下拉钩网显得不怎么靠谱 目前就业环境所趋，公司招聘要求明显提升，反观阿里招聘基本都是P6+，P7级别，要提升自身技能和软实力 数据结构和算法，二面基本会问简单的算法题目，刷LeetCode有用 CSS相关基础知识较薄弱 身体还是第一位","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"Vue响应式原理及手动实现一个简易的MVVM","slug":"Vue响应式原理及手动实现一个简易的MVVM","date":"2019-08-04T07:36:39.000Z","updated":"2019-08-04T17:13:57.000Z","comments":true,"path":"2019/08/04/Vue响应式原理及手动实现一个简易的MVVM/","link":"","permalink":"http://yoursite.com/2019/08/04/Vue响应式原理及手动实现一个简易的MVVM/","excerpt":"","text":"前置知识点：MVVM、MVC思想： 了解web前端发展历史有助于理解MVVM、MVC思想，历史发展总是朝着不断优化代码组织结构、易维护、封装复用的方向。揭开面纱，一切还是基于浏览器提供的API进行DOM操作。事实证明为项目开发效率的提升带来了重大意义。使用MVVM框架，只要改变JavaScript对象的状态，就会导致DOM结构作出对应的变化！这让我们的关注点从如何操作DOM变成了如何更新JavaScript对象的状态，而操作JavaScript对象比DOM简单多了！ 廖雪峰MVVM 推荐阅读： 什么是MVVM，MVC和MVVM的区别，MVVM框架VUE实现原理 mvc和mvvm的区别 JS设计模式（观察者模式、发布-订阅模式）： 观察者模式123456789101112131415161718192021class Observerable &#123; this.eventObj = &#123;&#125;; on(evName, fn) &#123; this.eventObj[evName] = this.eventObj[evName] ? [...this.eventObj[evName], fn] : [fn]; &#125; emit(evName, ...args) &#123; this.eventObj[evName].forEach((fn) =&gt; &#123; fn.apply(null, args); &#125;); &#125;&#125;// 实例化一个可观察对象const event = new Observerable();event.on('error', () =&gt; &#123; console.log('error1');&#125;)event.on('error', () =&gt; &#123; console.log('error2');&#125;)event.emit('error'); 代码参考自： Node.js && JavaScript 面试常用的设计模式二 发布-订阅模式 观察者模式与发布-订阅模式核心思想非常类似，观察者模式维护一个Observerable对象，发布-订阅模式集合所有Publisher和Subscriber对象形成EventHub信息中心，由信息中心负责通知订阅者，做到代码组织结构优化。 推荐阅读： 观察者模式 vs 发布-订阅模式 JS原生API： Object.defineProperty() js属性描述: getters与setters Document.createDocumentFragment() Node.childNodes|nodeType|textContent|innerHtml|firstChild|firstElementChild AngularJs响应式原理：通过脏值检测的方式比对数据是否有变更，来决定是否更新视图。最简单的方式就是通过setInterval()定时轮询检测数据变动，当然Google不会这么low。Angular只有在指定的事件触发时进入脏值检测，大致如下：DOM事件(譬如用户输入文本、点击按钮ng-click)、XHR响应事件$http、浏览器Location变更事件$location、Timer事件($timeout、$interval)、执行$digest()或$apply()。在Angular中组件是以树的形式组织起来的，相应地，检测器也是一棵树的形状。当一个异步事件发生时，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查，这种检查方式的性能存在很大问题。 程序思维什么是MVVM，MVC和MVVM的区别，MVVM框架VUE实现原理 Vue响应式原理： 通过Object.defineProperty()API监听对象的变化，实现操作js对象自动更新DOM（调用预先绑定的回调函数）。由于Object.defineProperty是ES5中一个无法shim的特性，这也就是Vue不支持IE8以及更低版本浏览器的原因，而且不能监听到数组的变化（Vue3.0开始使用ES6提供的Proxy）。 推荐阅读： Vue官网·深入响应式原理 Vue官网·数组更新检测 手动实现一个简易的MVVM： Vue响应式原理简单明了，难点在于Vue内部做了很多事情来实现双向绑定、性能优化等，通过算法模型减少DOM树更新和最大范围的重用。 实现Vue构造函数 123456789101112131415161718192021// Vue 构造函数function Vue(options = &#123;&#125;) &#123; this.$options = options; this._data = this.$options.data; // 实例化一个发布者（可观察对象） new Publisher(this._data); // 实现vm实例对data对象中的属性直接读取和赋值 for (let key in this._data) &#123; Object.defineProperty(this, key, &#123; enumerable: true, configurable: false, get() &#123; return this._data[key]; &#125;, set(newValue) &#123; this._data[key] = newValue; &#125; &#125;); &#125; new Compile(this.$options.el, this);&#125; 实现Compile简单编译DOM 123456789101112131415161718192021222324252627282930// Compile 简单编译DOMfunction Compile(el, vm) &#123; vm.$el = document.querySelector(el); const fragment = document.createDocumentFragment(); let child = null; while(child = vm.$el.firstChild) &#123; fragment.appendChild(child); // vm.$el的子元素被转移到fragment &#125; function replace(fragment) &#123; const pattern = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; Array.from(fragment.childNodes).forEach((node) =&gt; &#123; let text = node.textContent; if (node.nodeType === 3 &amp;&amp; pattern.test(text)) &#123; const key = RegExp.$1.trim(); // 为每一个&#123;&#123; xxx &#125;&#125;节点实例化一个订阅者，订阅data对象中的属性值变化 // 利用闭包，将node节点作为私有变量在内存中保存起来 new Subscriber(vm, key, (newValue) =&gt; &#123; node.textContent = text.replace(pattern, newValue); &#125;); // vm[key]对data对象取值触发get函数，此时EventHub静态属性target指向Subscriber实例，并被添加到events中 node.textContent = text.replace(pattern, vm[key]) &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; replace(node); &#125; &#125;); &#125; replace(fragment); vm.$el.appendChild(fragment);&#125; 发布-订阅模式实现响应 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 发布-订阅设计模式// EventHub信息中心function EventHub() &#123; this.events = [];&#125;EventHub.prototype.on = function(evName) &#123; this.events.push(evName);&#125;EventHub.prototype.notify = function() &#123; this.events.forEach((event) =&gt; &#123; event.update(); &#125;);&#125;// Publisher发布function Publisher(data) &#123; const eventHub = new EventHub(); for (let key in data) &#123; let value = data[key]; Object.defineProperty(data, key, &#123; enumerable: true, configurable: false, get() &#123; EventHub.target &amp;&amp; eventHub.on(EventHub.target); EventHub.target = null; return value; &#125;, set(newValue) &#123; if (newValue === value) &#123; return; &#125; value = newValue; eventHub.notify(); &#125; &#125;); &#125;&#125;// Subscriber订阅function Subscriber(vm, key, fn) &#123; this.vm = vm; this.key = key; this.fn = fn; EventHub.target = this;&#125;Subscriber.prototype.update = function () &#123; this.fn(this.vm[this.key]);&#125; 在发布-订阅模式中Publisher相当于Observerable可观察对象，传入Vue构造函数options中的data对象通过定义getters与setters变成可观察对象，任何取值赋值操作都可以发布信息到EventHub信息中心，由EventHub负责通知订阅者。 完整代码： github/simple-mvvm 参考文章： 这应该是最详细的响应式系统讲解了 实现一个简单的MVVM github/nano-mvc JS设计模式漫谈","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"mvvm","slug":"mvvm","permalink":"http://yoursite.com/tags/mvvm/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"对javascript EventLoop事件循环机制不一样的理解","slug":"对javascript EventLoop事件循环机制不一样的理解","date":"2019-07-23T10:58:36.000Z","updated":"2019-07-23T15:37:39.000Z","comments":true,"path":"2019/07/23/对javascript EventLoop事件循环机制不一样的理解/","link":"","permalink":"http://yoursite.com/2019/07/23/对javascript EventLoop事件循环机制不一样的理解/","excerpt":"","text":"前置知识点： 浏览器原理，浏览器内核5种线程及协作，JS引擎单线程设计推荐阅读： 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 【FE】浏览器渲染引擎「内核」 js异步编程，Promise实现推荐阅读： Javascript异步编程的4种方法 前端面试必考题Promise的源码解析 堆、栈、队列、执行栈、任务、微任务、事件循环机制♻️推荐阅读： JavaScript异步编程-基础篇 彻底搞懂浏览器Event-loop 这一次，彻底弄懂 JavaScript 执行机制 一次弄懂Event Loop（彻底解决此类面试问题） 事件循环机制 相信读者读完以上推荐的文章后，已经知道事件循环机制是怎么一回事了吧，也能从容应对面试。接下来我要谈谈自己的理解： 为什么会有事件循环机制 js设计之初就是单线程模式，代码也都是顺序执行，当遇到因为大量计算、http请求等需要额外的等待时间时，浏览器用户就会体验到卡顿了，所以所有的设计和改进初衷只有一个就是要快。 事件循环机制的产生 浏览器说我的内核是多线程，可以辅助JS引擎线程啊，Web Worker线程提供大量计算辅助（不能操作DOM），事件触发线程，定时触发器线程， 异步http请求线程。 执行栈（先进后出），由JS引擎线程控制，引用下面这个例子谈谈自己的理解： 123456789101112131415161718console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');// \"script start\"// \"script end\"// \"promise1\"// \"promise2\"// \"setTimeout\" 在ES5还没有Promise时代，异步回调很常见，上面例子中，通过解读Promise源码（前端面试必考题Promise的源码解析），我们可以把Promise转换成如下图式回调（个人理解，文章中的Promise源码也只是模拟，大部分浏览器已经原生支持）。 打印完script start, script end主执行栈出栈，如果Promise.resolve().then换成new Promise(executor)，脑补Promise换成回调函数，那么这个函数一执行，executor函数也就执行了，然后遇到异步回调，回调函数被其它对应的线程接手，启动观察者模式，完成后回调函数被推入事件任务队列，等待执行栈空了进入主线程执行 以上这种在异步函数中放同步函数的例子，为了合理解释输出顺序而推出了microtasks微任务的概念，请看下面的例子，脑补Promise换成回调函数，Promise.prototype.then内部执行了return new Promise()，js引擎在捕捉到Promise时，放到了由js引擎自身控制的微任务队列等待执行，也就造成promise1、2、3、4错开打印 123456789101112131415161718192021222324console.log('script start');new Promise(function(resolve, reject) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);new Promise(function(resolve, reject) &#123; console.log('promise3'); resolve();&#125;).then(function() &#123; console.log('promise4');&#125;);console.log('script end');// \"script start\"// \"promise1\"// \"promise3\"// \"script end\"// \"promise2\"// \"promise4\" microtasks微任务的概念完全为了解释异步函数中放同步函数的场景，而且各类文章和面试都是这种题目和例子，在实际开发过程中，你会在Promise中这么写么？，在我看来这种比较打印顺序太过于理论，而且可能会混乱你的思绪。就像下面的例子，Promise的resolve决定了Promise状态，就像在回调函数中满足了条件才会继续执行，例子中只是用setTimeout模拟异步请求，用之前的理论你可能觉得setTimeout被放入了事件任务队列，那没有resolve的Promise怎么解释呢？（放到微任务里一直阻碍第一个setTimeout宏任务执行吗？显然是不可能的，这不是跟设计事件循环机制初衷冲突了么） 12345678910111213141516171819202122setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; // 模拟异步请求 console.log('promise1'); resolve(); &#125;, 0);&#125;).then(function() &#123; console.log('promise2');&#125;);new Promise(function(resolve, reject) &#123; // resolve(); 注释掉resolve，使Promise一直处于‘pending’状态&#125;).then(function() &#123; console.log('promise2');&#125;);// \"setTimeout\"// \"promise1\"// \"promise2\" 个人认为把Promise，async/await脑补成原始的回调函数（模拟源码中模拟异步是用的setTimeout函数），而js引擎捕捉到setTimeout, setInterval就转给定时触发器线程处理，捕捉到XMLHttpReuqest, fetch就转给异步http请求线程，跟事件触发线程一起管理着事件任务队列，微任务的概念可以看作是当事件触发线程遇到几乎同时需要把回调函数放到事件任务队列时，Promise内部的异步标识函数优先级高于setTimeout函数吧，以上例子中没有执行resolve的Promise状态一直处于’pending’，事件触发线程压根没有放入到事件任务队列，总之浏览器会安排的妥妥的，不要打架，虽然js引擎线程只有一个（听我指挥排好队，咱们这都是同步代码执行ms级别，我开了很多其它线程处理需要等待的代码了）。以下例子模拟所谓的几乎同时把回调函数放到事件任务队列，记得把Promise脑补成原始的回调函数。仿佛回到了没有微任务的时代。 123456789101112131415161718192021222324252627setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; // 模拟异步请求 console.log('promise1'); resolve(); &#125;, 2000);&#125;).then(function() &#123; console.log('promise2');&#125;);new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; // 模拟异步请求 console.log('promise3'); resolve(); &#125;, 2000);&#125;).then(function() &#123; console.log('promise4');&#125;);// \"setTimeout\"// \"promise1\"// \"promise2\"// \"promise3\"// \"promise4\" 以上内容纯属未深入了解js情况下的个人理解，感觉是在努力摒弃微任务的概念，回归ES5回调函数时代，便于自身理解事件循环机制而做出的遐想。 多环境下的事件循环机制 在node环境、浏览器环境以及各个不同版本下js引擎处理的方式还不太一样。node比浏览器还复杂些😢（以后学Node.js时再看吧） 推荐阅读： NodeJS的Event Loop 又被node的eventloop坑了，这次是node的锅 关于Chrome浏览器73以下版本和73版本下`async/await`区别 参考文章： 更快的异步函数和 Promise Tasks, microtasks, queues and schedules","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"事件循环机制","slug":"事件循环机制","permalink":"http://yoursite.com/tags/事件循环机制/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"带你快速了解如何进行移动端开发","slug":"带你快速了解如何进行移动端开发","date":"2019-07-20T12:24:29.000Z","updated":"2019-07-21T05:17:21.000Z","comments":true,"path":"2019/07/20/带你快速了解如何进行移动端开发/","link":"","permalink":"http://yoursite.com/2019/07/20/带你快速了解如何进行移动端开发/","excerpt":"","text":"图片来自网络 正如上图所示，得益于JavaScript语言的强大和流行，前端工程师思维广度不断提升，这是要抢了IOS、Android工程师饭碗的节奏啊（当然也不可能完全替代，毕竟人家是原生开发）。 为什么混合型移动开发受欢迎👏 目前主流的框架都是一套代码多端适配，只需维护一套代码，降低用人成本 相比与传统的IOS、Android开发，每次发版都要经过应用市场的审核，一些经常需要更新的活动页H5就显得得心应手 相比与WebApp（即H5应用，只运行在移动端WebView浏览器上)，调用了设备API，交互体验和性能都得到了提升 NativeApp（传统的原生App开发模式） IOS：Object-c、Swift、SwiftUI、 Android：Java WebApp（H5应用） 运行在WebView浏览器上，只需要进行移动端的适配即可 开发框架：VueJS HybridApp（混合型应用开发模式） 正如下图所示：在原生的App中，使用WebView作为容器直接承载Web页面，相比直接运行在WebView浏览器上的H5应用，HybridApp就能调用原生API和组件实现相机、通讯录、短信等功能 图片引用自《Hybrid App技术解析 -- 原理篇》 简单原理：H5中的JS代码通过JSBridge（核心桥梁）与Native进行数据互相通信，页面还是在Webview浏览器引擎中显示 图片引用自《Hybrid App技术解析 -- 原理篇》 图片引用自《Hybrid APP架构设计思路》 开发框架：PhoneGap，Wex5，APICloud，Ionic，quickhybrid JSBridge深度剖析 Hybrid App开发设计与实现 Hybrid APP架构设计思路 Hybrid App技术解析 -- 原理篇 PerformanceHybridApp（高性能混合型应用开发模式） 相比于采用WebView渲染的HybridApp，PerformanceHybridApp改成调用原生API渲染UI进行交互通信，自然在性能和体验上更加接近NativeApp当然也额外保留了WebView容器功能 开发框架：ReactNative、Weex、Weex Ui、Flutter、BindingX、Rax、NativeScript 移动端跨平台开发的深度解析 全网最全 Flutter 与 React Native 深入对比分析 网易严选 App 感受 Weex 开发 ReactNative 快速入门笔记 Weex BindingX 尝鲜 小程序小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。 ​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。 ​网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具， 微信官方文档小程序与普通网页开发的区别 小程序：微信小程序、支付宝小程序、钉钉小程序、字节跳动小程序、百度小程序 开发框架：Taro、uni-app、Chameleon、WePY、mpvue、megalo 参考文章： 什么是Native、Web App、Hybrid、React Native 和 Weex？ quickhybrid H5和原生的职责划分 Hybrid App开发模式 Hybrid APP混合开发的一些经验和总结 常用的几种APP开发模式-脑图 浅谈Hybrid技术的设计与实现","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/tags/IOS/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"H5","slug":"H5","permalink":"http://yoursite.com/tags/H5/"},{"name":"WebView","slug":"WebView","permalink":"http://yoursite.com/tags/WebView/"},{"name":"Hybrid","slug":"Hybrid","permalink":"http://yoursite.com/tags/Hybrid/"},{"name":"Native","slug":"Native","permalink":"http://yoursite.com/tags/Native/"},{"name":"Weex","slug":"Weex","permalink":"http://yoursite.com/tags/Weex/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"},{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"},{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"我的奇思妙想","slug":"我的奇思妙想","date":"2019-07-20T09:11:21.000Z","updated":"2019-07-20T19:28:51.000Z","comments":true,"path":"2019/07/20/我的奇思妙想/","link":"","permalink":"http://yoursite.com/2019/07/20/我的奇思妙想/","excerpt":"","text":"Like To Do List In The Feature. 智能家居设备 👉淋浴喷头的水温和水流大小控制（电子数显，防水及触电危险⚠️） 个人博客 ✍️js中常用方法的实现（bind、call、apply、debounce、throttle） ✍️js数据结构和算法基础 ✍️js设计模式及应用 ✍️在量知公司的1年总结 个人项目 👉微信小程序：关于Apple相关产品报价，小程序·云开发基础版免费提供Serverless Framework 👉专注于为互联网行业求职者提供模拟面试、简历优化、公司筛选、能力预估、薪酬预估等服务的良心机构 👉在五百丁简历网选取一个模版开源（发现原网站有一些Bug） 兴趣爱好 Motorcycle（目标车型图片引用自哈罗摩托） 铃木GW250 💰26680 ⭐️质量可靠 ABS 铃木DL250 💰32680 ⭐️质量可靠 ABS 适合摩旅 售价三万元，铃木DL250，专为爱好摩旅的你而定制的公路旅行车！ 春风250NK 💰18900 ⭐️性价比高 ABS 加速性能好 春风400NK 💰29900 ⭐️性价比高 ABS 加速性能好 川崎Z400 💰46800 ⭐️质量可靠 ABS 加速性能好","categories":[{"name":"life","slug":"life","permalink":"http://yoursite.com/categories/life/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}],"keywords":[{"name":"life","slug":"life","permalink":"http://yoursite.com/categories/life/"}]},{"title":"js隐式类型转换学习总结","slug":"js隐式类型转换学习总结","date":"2019-06-29T02:49:45.000Z","updated":"2019-07-01T15:41:16.000Z","comments":true,"path":"2019/06/29/js隐式类型转换学习总结/","link":"","permalink":"http://yoursite.com/2019/06/29/js隐式类型转换学习总结/","excerpt":"","text":"为什么会写这篇博客，因为自己类型转换规则实在记不住，直接先看练习题，都没问题就直接pass。 前置知识点： js基本数据类型比较的是值是否相等 js引用数据类型比较的是引用的地址是否相等 ==比较会进行类型转换，===必须类型相同值也相等 \b==比较类型转换规则：刘小夕【面试篇】寒冬求职季之你必须要懂的原生JS(上) 首先排除特殊的null，undefined类型： 123null == undefined; // true0 == undefined; // false0 == null; // false 比较双方的类型相同，则进行值的判断： 1[] == []; // false（类型相同但引用的地址不同） 比较双方的类型不同，进行类型转换，规则如下： 若其中一方为object且另一方为string、number或者symbol, 将object转为基本类型再进行判断 1234[] == ''; // true[] == 0; // true[null] == 0; // true[undefined] == 0; // true 若其中一方为boolean, 将boolean转为number再进行判断 12true == 1; // truefalse == 0; // true 若双方类型为string和number, 将string转换成number 1'12' == 12; // true \bobject转换成基本类型规则：object这种复杂类型转换成基本类型时，会调用对象的valueOf和toString方法。 1234&#123;&#125;.toString(); // '[object Object]'[1,2,3].valueOf(); // [1,2,3][1,2,3].toString(); // '1,2,3'Object.prototype.toString.call([1,2,3]); // '[object Array]' (可判断是否为数组) valueOf和toString方法调用顺序： 若显示定义了[Symbol.toPrimitive]属性，只调用该接口，若返回的不是基本数据类型，抛出错误。 默认的调用规则： 非Date类型对象，hint是default时，调用顺序为：valueOf &gt;&gt;&gt; toString，即valueOf返回的不是基本数据类型，才会继续调用toString，如果toString返回的还不是基本数据类型，那么抛出错误。 如果hint是string(Date对象默人的hint是string) ，调用顺序为：toString &gt;&gt;&gt; valueOf，即toString返回的不是基本数据类型，才会继续调用valueOf，如果valueOf返回的还不是基本数据类型，那么抛出错误。 如果hint是number，调用顺序为：valueOf &gt;&gt;&gt; toString。 刘小夕【Step-By-Step】高频面试题深入解析 / 周刊01 12(new Date()).toString(); // 'Sun Jun 30 2019 16:53:46 GMT+0800 (中国标准时间)'(new Date()).valueOf(); // 1561884790571 关于hint, [Symbol.toPrimitive]示例可访问上文引用链接关于[Symbol.toPrimitive]可参考：- 阮一峰·ECMAScript 6 入门 string转换成number规则：Number()和parseInt()方法1234Number('12abc'); // NaNNumber(undefined); // NaNNumber(null); // 0parseInt('12abc'); // 12 parseInt()经典面试题alentan为什么 [1, 7, 11].map(parseInt) 返回 [1, NaN, 3] String()和toString()方法1234undefined.toString(); // TypeError: Cannot read property 'toString' of undefinednull.toString(); // TypeError: Cannot read property 'toString' of nullString(undefined); // 'undefined'String(null); // 'null' radix为2时，NumberObject会被转换为二进制值表示的字符串12var num = 13;console.log(num.toString(2)); typeof判断类型：typeof方法返回值：undefined, boolean, number, string, symbol, function, object 12345678typeof null; // 'object'typeof [1,2,3]; // 'object'typeof new Boolean(true); // 'object'typeof new Number(1); // 'object'typeof new String(\"abc\"); // 'object'typeof NaN; // 'number'typeof (typeof 1); // 'string'typeof undefined; // 'undefined' 练习题 []开辟了一块堆内存，地址存在栈内存，![]返回false 123if ([]) &#123; ... // true&#125; 比较双方的类型相同，则进行值的判断，栈内存地址不同 12[] == []; // false&#123;&#125; == &#123;&#125;; // false 解题参考：- 【面试篇】寒冬求职季之你必须要懂的原生JS(上) 123[] == ![] // true&#123;&#125; == !&#123;&#125; // false&#123;&#125; == '[object Object]' // true 疑惑：文中最后一步Number([])确实为0，但是和object转换成基本类型规则：似乎有冲突。 运算符进行隐式类型转换1234567891011121314'12' + 1; // '121'（String）1 + 'true'; // '1true'1 + true; // 21 + undefined; // NaN1 + null; // 1'12' * 1; // 12（Number）'12' - 1; // 11（Number）'a' - 1; // NaN2 &gt; '10'; //false'2' &gt; '10'; // true'abc' &gt; 'b'; // false'abc' &gt; 'aad'; // true[] + &#123;&#125;; // '[object Object]'[] + []; // '' 字符串连接符+：只要+号两边有一边是字符串 算术运算符+：+号两边都是数字 特殊类型比较null, undefined, NaN的比较 123undefined == null; // trueNaN == NaN; // falseNaN == null; // false Can (a== 1 &amp;&amp; a ==2 &amp;&amp; a==3) ever evaluate to true? 123if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; // ...&#125; 解答： 利用数组的toString会隐含调用Array.join方法 123a = [1,2,3];a.join = a.shift;console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3); 重写Object的toString或者valueOf 1234567const a = &#123; i: 1, toString: function () &#123; return a.i++; &#125;&#125;console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3); 参考文章： 【面试篇】寒冬求职季之你必须要懂的原生JS(上) 【Step-By-Step】高频面试题深入解析 / 周刊01 [译]送你43道JavaScript面试题 老码农的字节跳动前端面试总结（2面已凉） MDN·typeof Js 中那些 隐式转换 js面试题大坑——隐式类型转换 有意思的JavaScript面试题：如何让(a ==1 && a== 2 && a==3) 的值为true","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"类型转换","slug":"类型转换","permalink":"http://yoursite.com/tags/类型转换/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"js执行上下文、词法作用域、块级作用域相关学习","slug":"js执行上下文、词法作用域、块级作用域相关学习","date":"2019-06-26T10:07:21.000Z","updated":"2019-07-23T15:43:10.000Z","comments":true,"path":"2019/06/26/js执行上下文、词法作用域、块级作用域相关学习/","link":"","permalink":"http://yoursite.com/2019/06/26/js执行上下文、词法作用域、块级作用域相关学习/","excerpt":"","text":"JavaScript引擎JavaScript引擎的一个流行示例是Google的V8引擎。例如，在Chrome和Node.js中使用V8引擎，下面是一个非常简化的视图： 浏览器中的JavaScript解释器是作为一个单线程实现的，这实际上意味着，在浏览器中，一次只能发生一件事，其他操作或事件将排队在所谓的执行堆栈中。 lvwxxJavaScript中的执行上下文和堆栈是什么 词法作用域 函数作用域和块级作用域 块级作用域与函数声明 ES5 只有全局作用域和函数作用域，没有块级作用域。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。 ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 阮一峰块级作用域 let、const必须在{}大括号包裹下产生块级作用域，来感受下let和var的区别吧 12345678var aa = 'bb';function fn() &#123; console.log(aa); &#123; // 在块级作用域内var声明变量 var aa = 'aa'; &#125;&#125;fn(); // undefined 12345678var aa = 'bb';function fn() &#123; console.log(aa); &#123; // 在块级作用域内let声明变量 let aa = 'aa'; &#125;&#125;fn(); // 'bb' 123456789101112function bs() &#123; console.log(1);&#125;function fn() &#123; bs(); &#123; // 在块级作用域内声明函数 function bs() &#123; console.log(2); &#125; &#125;&#125;fn(); // TypeError: bs is not a function 123456789101112function fn() &#123; let a = 1; if (true) &#123; // 在块级作用域内声明变量 a = 5; var b = 2; const c = 3; &#125; console.log(a); // 5 console.log(b); // 2 console.log(c); // ReferenceError: c is not defined&#125;fn(); 123456789101112function fn() &#123; let a = 1; if (false) &#123; // 在块级作用域内声明变量 a = 5; var b = 2; const c = 3; &#125; console.log(a); // 1 console.log(b); // undefined console.log(c); // ReferenceError: c is not defined&#125;fn(); 变量提升暂时性死区使用let/const声明的变量，从一开始就形成了封闭作用域，在声明变量之前是无法使用这个变量的，这个特点也是为了弥补var的缺陷（var声明的变量有变量提升） yeyan1996近一万字的ES6语法知识点补充 12console.log(aa); // ReferenceError: Cannot access 'aa' before initialization）let aa; 剖析暂时性死区的原理，其实let/const同样也有提升的作用，但是和var的区别在于： var在创建时就被初始化，并且赋值为undefined let/const在进入块级作用域后，会因为提升的原因先创建，但不会被初始化，直到声明语句执行的时候才被初始化，初始化的时候如果使用let声明的变量没有赋值，则会默认赋值为undefined，而const必须在初始化的时候赋值。而创建到初始化之间的代码片段就形成了暂时性死区 yeyan1996近一万字的ES6语法知识点补充 ES6 Class 不存在变量提升1234console.log(Test); // ReferenceError: Cannot access 'Test' before initializationclass Test &#123; // ...&#125; 解释器如何评估JS代码（evaluate） 扫描被调用函数中的代码 在代码执行前，创建执行上文 进入创建阶段 初始化作用域链 创建变量对象 创建arguments对象，检查参数上下文，初始化名称和值，并创建引用副本 扫描上下文中函数的声明 对于找到的每个函数，在变量对象中创建一个属性，该属性是确切的函数名，该函数在内存中有一个指向该函数的引用指针 如果函数名已经存在，指针将会被覆盖 扫描变量的声明 对于找到的每个变量，在变量对象中创建一个属性，该属性是确切的变量名，该变量的值是undefined 如果变量名已经存在，将不会做任何处理继续执行 决定this的值 代码执行阶段 变量赋值，按顺序执行代码 lvwxxJavaScript中的执行上下文和堆栈是什么 结合自身的感悟如下： 知道了js代码执行前有预编译这么一回事，也就能掌握变量提升，解释器根据var, function等关键字进行预编译，function声明整体前置，var声明变量并赋值为undefined，体现了function是一等公民 12345678910111213141516(function() &#123;console.log(foo); // foo() &#123; return 'hello'; &#125;console.log(bar); // undefinedvar bar = function() &#123; return 'world';&#125;;var foo = 'hello';function foo() &#123; return 'hello';&#125;console.log(foo); // 'hello'&#125;());​ 词法作用域决定了函数执行上下文作用域，跟函数在哪调用没有关系（this在任何情况下都不指向函数的词法作用域，this是在函数运行时，创建上下文的时候确定的） 12345678910111213141516171819function a() &#123; var myOtherVar = \"inside A\"; b();&#125;function b() &#123; var myVar = \"inside B\"; console.log(\"myOtherVar:\", myOtherVar); // 'global otherVar' function c() &#123; console.log(\"myVar:\", myVar); // 'inside B' &#125; c();&#125;var myOtherVar = \"global otherVar\";var myVar = \"global myVar\";a(); 执行上下文执行上下文：当前代码正在执行的环境（作用域），一般有以下三种情况： 全局代码 – 代码首次开始执行的默认环境 函数代码 – 每当进入一个函数内部 Eval代码 – eval内部代码执行时 lvwxxJavaScript中的执行上下文和堆栈是什么 Nothing special is going on here, we have 1 global context represented by the purple border and 3 different function contexts represented by the green, blue and orange borders. There can only ever be 1 global context, which can be accessed from any other context in your program. You can have any number of function contexts, and each function call creates a new context, which creates a private scope where anything declared inside of the function can not be directly accessed from outside the current function scope. In the example above, a function can access a variable declared outside of its current context, but an outside context can not access the variables / functions declared inside.（理解为作用域链） David Shariffwhat-is-the-execution-context-in-javascript 现在我们知道每当有函数被调用时，都会创建一个新的执行上下文。在js内部，每个执行上文创建都要经历下面2个阶段： 创建阶段（函数被调用，但还没有执行内部代码） 创建作用域链 创建变量和参数 决定this指向 代码执行阶段 变量赋值，执行代码 lvwxxJavaScript中的执行上下文和堆栈是什么 this 全面解析 推荐阅读：刘小夕 - 嗨，你真的懂this吗？ 闭包 参考文章： JavaScript中的执行上下文和堆栈是什么 JavaScript是如何工作的：引擎，运行时和调用堆栈的概述！ 5分钟读懂JavaScript预编译 JavaScript 究竟是怎样执行的？ 精读《你不知道的 javascript（上卷）》 精读《你不知道的 javascript（中卷）》 What is the Execution Context & Stack in JavaScript? 你不可不知道的 JavaScript 作用域和闭包 JS函数作用域以及变量提升问题 块级作用域（阮一峰·ECMAScript 6 入门）","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"编译","slug":"编译","permalink":"http://yoursite.com/tags/编译/"},{"name":"作用域","slug":"作用域","permalink":"http://yoursite.com/tags/作用域/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"js原型、原型链、继承相关学习心得","slug":"js原型、原型链、继承相关学习心得","date":"2019-06-20T03:24:22.000Z","updated":"2019-06-26T11:45:36.000Z","comments":true,"path":"2019/06/20/js原型、原型链、继承相关学习心得/","link":"","permalink":"http://yoursite.com/2019/06/20/js原型、原型链、继承相关学习心得/","excerpt":"","text":"前置知识点： js基本数据类型和引用数据类型（基本数据类型有： null, undefined, Boolen, Number, String, Symbol） 计算机堆、栈内存（栈内存存的是基本类型和引用类型的地址，堆内存由于树状结构可以延伸适合引用类型如Array, Object） js中this指向及bind，call，apply方法使用，参阅call、apply和bind的实现 引生思考点 js语言原型和原型链为什么这么设计，好处与不好之处，与Java语言最大的区别是什么？ 浅拷贝与深拷贝如何实现？ js闭包知识点 js原型、原型链基本概念ES5 和 ES6 继承的区别 ES5原型链继承 12345678910111213141516171819function Super() &#123; this.xxx = 'hello world!';&#125;Super.prototype.sayHello = function() &#123; console.log(this.xxx);&#125;function Son() &#123; // ...&#125;Son.prototype = new Super(); // 原型链式继承// Son.prototype = Object.create(Super.prototype);Son.prototype.constructor = Son; // 修复constructorvar sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!'; 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例instanceof方法通过层层查找原型链判断的 缺点： 来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参 ES6继承 12345678910111213141516class Super &#123; constructor() &#123; this.xxx = 'hello world!'; &#125; sayHello() &#123; console.log(this.xxx); &#125;&#125;class Son extends Super &#123; // ...&#125;var sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!'; ES6继承和原型链式继承还是有本质区别的，ES6中 Son 类实例是自己本身拥有了xxx属性的，因为在子类的constructor构造函数中运行super()方法调用了父类构造函数（ES5的调用父类构造函数继承） ES6中方法都是不可枚举的，Son 类实例调用 sayHello 方法和原型式继承原理类似 ES5中构造函数是function函数本身，而ES6中构造函数是 constructor 函数 关于ES6 class 可以重开一篇博客了, 先推荐阅读两篇文章 ES6 javascript中class静态方法、属性与实例属性用法示例 react组件中的constructor和super小知识 以上图片引用自keenwon.com 实现ES6的class语法（2019-06-26·补充）123456789101112function inherit(subType, superType) &#123; subType.prototype = Object.create(superType.prototype, &#123; constructor: &#123; enumerable: false, configurable: true, writable: true, value: subType, &#125; &#125;); Object.setPrototypeOf(subType, superType);&#125; ES6 的 class 内部是基于寄生组合式继承，它是目前最理想的继承方式，通过 Object.create 方法创造一个空对象，并将这个空对象继承 Object.create 方法的参数，再让子类（subType）的原型对象等于这个空对象，就可以实现子类实例的原型等于这个空对象，而这个空对象的原型又等于父类原型对象（superType.prototype）的继承关系 而 Object.create 支持第二个参数，即给生成的空对象定义属性和属性描述符/访问器描述符，我们可以给这个空对象定义一个 constructor 属性更加符合默认的继承行为，同时它是不可枚举的内部属性（enumerable:false） 而 ES6 的 class 允许子类继承父类的静态方法和静态属性，而普通的寄生组合式继承只能做到实例与实例之间的继承，对于类与类之间的继承需要额外定义方法，这里使用 Object.setPrototypeOf 将 superType 设置为 subType 的原型，从而能够从父类中继承静态方法和静态属性 yeyan1996一个合格的中级前端工程师必须要掌握的28个JavaScript技巧 ES5实现继承的其它方式调用父类构造函数继承123456789101112131415function Super(xxx) &#123; this.xxx = xxx;&#125;Super.prototype.sayHello = function() &#123; console.log(this.xxx);&#125;function Son() &#123; Super.call(this, 'hello world!'); // 调用父类构造函数&#125;var sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!';sonInstance.sayHello(); // TypeError: sonInstance.sayHello is not a function 特点： 创建子类实例时，可以向父类传递参数 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 组合继承12345678910111213141516171819function Super(xxx) &#123; this.xxx = xxx;&#125;Super.prototype.sayHello = function() &#123; console.log(this.xxx);&#125;function Son() &#123; Super.call(this, 'hello world!'); // 调用父类构造函数&#125;Son.prototype = new Super();Son.prototype.constructor = Son; // 修复constructorvar sonInstance = new Son();console.log(sonInstance.xxx); // 'hello world!';sonInstance.sayHello(); // 'hello world!'; 特点： 创建子类实例时，可以向父类传递参数 既是子类的实例，也是父类的实例 实例拥有与父类同名的自己的属性（亦是缺点） 既能继承父类的实例属性和方法，又能继承原型属性/方法 缺点： 调用了两次父类构造函数，子类实例上属性将子类原型上的那份屏蔽了 寄生组合继承12345678910111213141516171819function Super(xxx) &#123; this.xxx = xxx;&#125;function Son(xxx) &#123; Super.call(this, xxx); // 调用父类构造函数&#125;// 创建一个空方法，避免再次调用父类的构造函数(function () &#123; var Temp = function() &#123;&#125;; Temp.prototype = Super.prototype; Son.prototype = new Temp();&#125;)();Son.prototype.constructor = Son; // 修复constructorvar sonInstance = new Son('hello world!');console.log(sonInstance.xxx); // 'hello world!'; 特点： 结合以上所有继承方式的优点 完整的原型图 参考文章： 完整原型链详细图解（构造函数、原型、实例化对象） JS实现继承的几种方式 详解ES5和ES6的继承","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"原型","slug":"原型","permalink":"http://yoursite.com/tags/原型/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"前端面试必考题Promise的源码解析","slug":"前端面试必考题Promise的源码解析","date":"2019-06-18T09:55:45.000Z","updated":"2019-06-19T08:20:32.000Z","comments":true,"path":"2019/06/18/前端面试必考题Promise的源码解析/","link":"","permalink":"http://yoursite.com/2019/06/18/前端面试必考题Promise的源码解析/","excerpt":"","text":"考察知识点： js迭代器 js构造函数、原型、原型链 js执行栈、事件循环机制 伪源码实现：Promise构造函数 创建一个Promise实例，通过new一个Promise（接受一个函数作为参数），该函数接受resolve, reject两个方法作为参数。 每个Promise只有三种状态：pending，fulfilled 和 rejected，状态只能从 pending 转移到 fulfilled 或者 rejected，一旦状态变成fulfilled 或者 rejected，就不能再更改其状态。 123456789101112131415161718192021222324252627282930function Promise3(executor) &#123; const self = this; self.status = 'pending'; self.value = undefined; self.reason = undefined; self.onResolvedCallbacks = []; self.onRejectedCallbacks = []; function resolve(value) &#123; if (self.status === 'pending') &#123; self.status = 'resolved'; self.value = value; self.onResolvedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; function reject(reason) &#123; if (self.status === 'pending') &#123; self.status = 'rejected'; self.reason = reason; self.onRejectedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125; 定义在Promise原型上方法then，可被实例调用 通过判断上一个Promise的状态执行不同的代码 正常情况下第一个Promise执行器中是异步代码，会先执行then()函数，then函数两个参数onFulfilled，onRejected会被暂存到onResolvedCallbacks，onRejectedCallbacks中，在第一步的异步执行器executor(resolve, reject)中完成执行 为了实现Promise的链式调用，在then方法中return promise，所以在new Promise的执行器中手动加了setTimeout实现异步执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Promise3.prototype.then = function (onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === 'function' ? onRejected : err =&gt; &#123; throw err &#125;; const self = this; let promise2; if (self.status === 'resolved') &#123; promise2 = new Promise3(function(resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status === 'rejected') &#123; promise2 = new Promise3(function(resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status === 'pending') &#123; promise2 = new Promise3(function(resolve, reject) &#123; self.onResolvedCallbacks.push(function () &#123; setTimeout(function() &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; onRejected(e); &#125; &#125;); &#125;); self.onRejectedCallbacks.push(function () &#123; setTimeout(function() &#123; try &#123; let x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; onRejected(e); &#125; &#125;); &#125;); &#125;); &#125; return promise2;&#125; 定义resolvePromise方法 上一个Promise返回值有3中情况（也是该函数取名的缘由） 普通值 promise对象 thenable对象/函数 通过自身迭代和在then方法中的引用，直至返回resolve普通值或者报错 12345678910111213141516171819202122232425262728293031function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError('Chaining cycle')); // 循环引用报错 &#125; let called; if (x &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123; let then = x.then; if (typeof then === 'function') &#123; then.call(x, function(y) &#123; if (called) return; called = true; resolvePromise(promise2, y, resolve, reject); &#125;, function(err) &#123; if (called) return; called = true; reject(err); &#125;); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125; Promise的静态方法及其它方法：Promise.resolve1234567891011121314Promise.resolve = function (param) &#123; if (param instanceof Promise) &#123; return param; &#125; return new Promise((resolve, reject) =&gt; &#123; if (param &amp;&amp; param.then &amp;&amp; typeof param.then === 'function') &#123; setTimeout(() =&gt; &#123; param.then(resolve, reject); &#125;); &#125; else &#123; resolve(param); &#125; &#125;);&#125; Promise.reject12345Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125; Promise.prototype.catch123Promise.prototype.catch = function (onRejected) &#123; return this.then(null, onRejected);&#125; Promise.prototype.finally1234567891011Promise.prototype.catch = function (callback) &#123; return this.then((value) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; return value; &#125;); &#125;, (err) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; throw err; &#125;); &#125;);&#125; Promise.all123456789101112131415161718192021222324Promise.all = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let index = 0; let result = []; if (promises.length === 0) &#123; resolve(result); &#125; else &#123; function processValue(i, data) &#123; result[i] = data; if (++index === promises.length) &#123; resolve(result); &#125; &#125; promises.forEach((promise, i) =&gt; &#123; Promise.resolve(promise).then((data) =&gt; &#123; processValue(i, data); &#125;, (err) =&gt; &#123; reject(err); return; &#125;); &#125;); &#125; &#125;);&#125; Promise.race1234567891011121314151617Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; if (promises.length === 0) &#123; return; &#125; else &#123; promises.forEach((promise, i) =&gt; &#123; Promise.resolve(promise).then((data) =&gt; &#123; resolve(data); return; &#125;, (err) =&gt; &#123; reject(err); return; &#125;); &#125;); &#125; &#125;);&#125; promise测试库12npm install promises-aplus-tests -Dnpx promises-aplus-tests promise.js 参考文章： Promise/A+ 规范文档 Promise详解与实现（Promise/A+规范） 手写实现满足 Promise/A+ 规范的 Promise Promise的源码实现（完美符合Promise/A+规范） 手动实现一个满足promises-aplus-tests的Promise","categories":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}],"keywords":[{"name":"font-end","slug":"font-end","permalink":"http://yoursite.com/categories/font-end/"}]},{"title":"读李飞飞人物志有感","slug":"读李飞飞人物志有感","date":"2019-06-04T08:32:44.000Z","updated":"2019-06-21T07:44:36.000Z","comments":true,"path":"2019/06/04/读李飞飞人物志有感/","link":"","permalink":"http://yoursite.com/2019/06/04/读李飞飞人物志有感/","excerpt":"","text":"20世纪70年代，李飞飞生于成都。 那时的成都，远没有今天繁华。但是，李飞飞的父母特别注重培养她的好奇心，一有展览就带她去，让她接触到更大的世界、更新奇的事物。 同时，家里还有一条很有趣的家规：李飞飞放学回家后只能在40分钟内做作业，40分钟后就可以看课外书、可以玩，干啥都可以，但就是不能再做作业。 父母此举，就是为了让李飞飞养成专注高效的习惯，做事不拖延，不左顾右盼。这样，就可以为自己留出充足时间，做自己感兴趣的事。 程序人生她拒绝麦肯锡 Offer，建立图片训练数据库，斯坦福 AI 实验室负责人 | 人物志 为这种教育方式点赞，相比近期被推到热点新闻的996上班制度，工作效率才是应该提高的方向。","categories":[{"name":"life","slug":"life","permalink":"http://yoursite.com/categories/life/"}],"tags":[{"name":"education","slug":"education","permalink":"http://yoursite.com/tags/education/"}],"keywords":[{"name":"life","slug":"life","permalink":"http://yoursite.com/categories/life/"}]},{"title":"Hexo+Github","slug":"Hexo-Github","date":"2019-05-28T08:43:49.000Z","updated":"2019-05-29T03:37:25.000Z","comments":true,"path":"2019/05/28/Hexo-Github/","link":"","permalink":"http://yoursite.com/2019/05/28/Hexo-Github/","excerpt":"","text":"Hexo+GitHub 搭建个人网站教程 Hexo简介 Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。首先电脑上需要安装Node.js依赖。 12345$ npm install hexo-cli -g ##安装hexo脚手架$ hexo init blog ##初始化hexo$ cd blog$ npm install$ hexo server","categories":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}],"keywords":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-25T18:17:52.000Z","updated":"2019-05-29T03:54:21.000Z","comments":true,"path":"2018/08/26/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}]}]}